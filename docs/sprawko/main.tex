\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{polski}
\usepackage[hidelinks]{hyperref}
\usepackage{import}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{float}
\usepackage[justification=centering]{caption}
\usepackage[htt]{hyphenat}

\graphicspath{{images/}}

\begin{document}

\begin{flushright}
    \today
\end{flushright}

\begin{flushleft}
    \begin{tabular}{ll}
        Bartosz Kosmala  & 140726 \\
        Hubert Knioła    & 139644 \\
        Mateusz Kuźniak  & 139092 \\
        Jordan Kondracki & 140721
    \end{tabular}
\end{flushleft}

\vspace{0.5cm}

\begin{center}
    \textbf{Sztuczna Inteligencja - laboratorium}\\[0.3cm]
    Sprawozdanie końcowe\\[0.3cm]
    \textit{\textbf{Rogo Puzzle z wykorzystaniem paradygmatu CSP/FD}}
\end{center}

\vspace{0.5cm}

\tableofcontents

\newpage

\section{Opis zadania}

Celem projektu jest stworzenie aplikacji, która umożliwia rozwiązanie łamigłówki
\textit{Rogo}, zgodnie z paradygmatem CSP (ang. \textit{Contraint Satisfaction Problem}) w skończonej
dziedzinie (ang. \textit{Finite Domain}).

Łamigłówka polega na ustaleniu na planszy zapętlonej ścieżki, która zawiera pola z liczbami.
Ścieżek na takiej planczy można znaleźć wiele ale rozwiązaniem jest ta ścieżka,
której suma liczb na jej polach jest największa.

\section{Założenia realizacyjne}

W tym rozdziale zawarto informację o algorytmie i technologii wykorzystanej do
rozwiązania problemu.

\subsection{Zdefiniowanie problemu oraz opis algorytmu}

Rozwiązaniem CSP jest przypisanie każdej zmiennej wartości z jej dziedziny
spełniającej wszystkie ograniczenia. Zadaniem jest znalezienie jednego
lub wszystkich rozwiązań \cite{cotocsp}.

Do prawidłowego działania należy wprowadzić dane wejściowe takie jak: \begin{itemize}
    \item wymiary planszy,
    \item ilość kroków,
    \item tablica dwuwymiarowa zawierająca liczby znajdujące się na polach planszy.
\end{itemize}

Następnie wyznaczana jest największa wartość znajdująca się na planszy. 
Wyliczana jest również suma wszystkich dodatnich liczb w tablicy w celu określenia maksymalnej wartości planszy.
Kolejnym elementem jest implementacja ograniczeń takich jak:

\begin{itemize}
    \item zapewniających, że każdy krok jest różny (żadna para kroków nie ma takich samych współrzędnych),
    \item ustalających ilość punktów na każdym kroku rozwiązania,
    \item zliczających sumę punktów zdobytych dla danego rozwiązania,
    \item sprawdzających czy pole niedozwolone nie znajduje się w rozwiązaniu,
    \item sprawdzających, że kolejny krok jest w bezpośrednim kontakcie z obecnym (tzn. w odległości jednego pola nie wliczając przekątnych),
    \item sprawdzających czy ostatni krok w rozwiązaniu znajduje się w bezpośrenim kontakcie z pierwszym krokiem, w celu zamknięcia pętli.
\end{itemize}

Ograniczenia te są głównym elementem implementacji całego programu.
Są one odpowiedzialne za znalezienie najlepszego rozwiązania. Podczas implementacji sugerowaliśmy 
się rozwiązaniem umieszczonym na blogu ,,My Constraint Programming Blog'' \cite{hakan}. 
Pełen kod rozwiązania w języku \textit{MiniZinc} można zobaczyć na listingu 1.

\hfill

\lstinputlisting[numbers=left, captionpos=b, frame=single, language=Python, caption=Rozwiązanie łamigłówki w języku \textit{MiniZinc}]{../../src/nocommentrogo.mzn}

\subsection{Język programowania, narzędzia informatyczne, środowisko i biblioteki}

Do implementacji aplikacji wykorzystamy język programowania ogólnego przeznaczenia
\textit{Python} oraz język \textit{MiniZinc}, który pozwala na definiowanie
problemów CSP \cite{minizinc}.

Do pisania kodu wykorzystamy narzędzie \textit{Visual Studio Code}. Do kontroli
wersji aplikacji użyjemy systemu \textit{Git} wraz z platformą \textit{GitHub}.

W implementacji skorzystamy z biblioteki \texttt{minizinc}
dla języka \textit{Python}. Pozwala ona na korzystanie ze środowiska
\textit{MiniZinc} z poziomu interpretera. Umożliwia ona m.in. komplilację modeli
oraz rozwiązywanie ich. Do stworzenia interfejsu graficznego wykorzystamy standardową bibliotekę
Pythona o nazwie \texttt{tkinter}.

\section{Podział prac}

Podział prac przy projekcie pomiędzy jego członków jest widoczny na
tablicy \ref{tab:podzialprac}.

\begin{table}[H]
    \caption{\label{tab:podzialprac}Podział prac przy projekcie}
    \begin{tabularx}{\textwidth}{ | p{\dimexpr.28\linewidth-2\tabcolsep-1.3333\arrayrulewidth} | X | }
        \hline
        Autor            & Wkład  \\
        \hline
        Bartosz Kosmala  &
        \begin{itemize}
            \item redagowanie sprawozdań roboczych
            \item implementacja interfejsu graficznego aplikacji
            \item zapoznanie się z wymaganymi technologiami
        \end{itemize} \\
        \hline
        Hubert Knioła    &
        \begin{itemize}
            \item implementacja interfejsu graficznego aplikacji
            \item zapoznanie się z wymaganymi technologiami
            \item pomoc merytoryczna przy sprawozdaniu
        \end{itemize} \\
        \hline
        Mateusz Kuźniak  &
        \begin{itemize}
            \item implementacja modelu CSP
            \item zapoznanie się z wymaganymi technologiami
            \item pomoc merytoryczna przy sprawozdaniu
        \end{itemize} \\
        \hline
        Jordan Kondracki &
        \begin{itemize}
            \item redagowanie sprawozdań roboczych
            \item implementacja modelu CSP
            \item zapoznanie się z wymaganymi technologiami
        \end{itemize} \\
        \hline
    \end{tabularx}
\end{table}

\section{Opis implementacji}

W tym rozdziale opiszemy strukturę aplikacji klienckiej naszego systemu oraz przedstawimy 
szczegóły jej implementacji. Kod programu można znaleźć wewnątrz folderu \texttt{src} w głównym
katalogu repozytorium.

\subsection{Struktury danych wykorzystywane w programie}

Zrealizowany program zawiera w sobie 8 klas z czego 4 są elementami czysto prezentacyjnymi - mowa
o klasach \texttt{Input}, \texttt{Button}, \texttt{Cell} oraz \texttt{ResultsView} z pakietu \texttt{components}.
Opakowują one istniejące komponenty biblioteki \texttt{tkinter} w bardziej zwięzłe elementy realizujące
funkcjonalności pola do wprowadzania tekstu z opisem, przycisku, komórki planszy i okna z podsumowaniem wyników.

\subsubsection{Klasa \texttt{SolverArguments}}

To klasa opakowująca wymagane argumenty solvera w pojedynczy obiekt. W skład jej atrybutów wchodzi
liczba wierszy, kolumn, kroków oraz stan planszy w postaci macierzy.

Posiada ona jedną statyczną metodę \texttt{from\_dzn(filepath: str) -> SolverArguments}, która
zwraca obiekt stworzony na podstawie pliku z rozszerzeniem \texttt{.dzn} (plik z danymi wejściowymi w formacie \textit{MiniZinc})
którego ścieżkę w systemie przyjmuje jako parametr.

Jedyną niestatyczną metodą tej klasy jest \texttt{to\_file\_string() -> str}, która tworzy na podstawie stanu obiektu string eksportowany do pliku.
Ta funkcjonalność jest wykorzystywana w głównej klasie programu.

\subsubsection{Klasa \texttt{SolverResults}}

Ta klasa wyodrębnia część danych z obiektu zwracanego po rozwiązaniu modelu przez bibliotekę \texttt{minizinc}.
Jej atrybuty stanowią dane wykorzystywane w warstwie prezentacji rozwiązania. Realizuje ona wzorzec
\textbf{DTO} (ang. \textit{Data Transfer Object}). 

Jedyna statyczna metoda tej klasy to \texttt{from\_minizinc\_results(solution: Tuple[Status, Optional[Union[List[Dict], Dict]], Dict]) -> SolverResults}.
Przyjmuje ona obiekt zwracany przez metodę \texttt{Instance.solve()} z biblioteki \textit{MiniZinc} i wybiera z niego oczekiwane dane zwracając
je w postaci obiektu \texttt{SolverResults}.


\subsubsection{Klasa \texttt{CellBoard}}

Jest to klasa reprezentująca planszę komórek, które można wypełnić zgodnie z założeniami łamigłówki.
Opakowuje ona macierz komponentów \texttt{Cell} i udostępnia wysokopoziomowe abstrakcje.

Do metod tej klasy należą:
\begin{itemize}
    \item \texttt{is\_empty() -> bool} - sprawdza czy plansza jest pusta,
    \item \texttt{has\_errors() -> bool} - sprawdza którakolwiek z komórek zawiera błędy,
    \item \texttt{clear() -> bool} - usuwa komórki planszy,
    \item \texttt{new\_row(cells: List[Cell]) -> None} - dodaje do planszy nowy wiersz komórek podanych jako parametr,
    \item \texttt{\_\_mark\_generator(results: SolverResults) -> Generator} - tworzy generator kroków wykorzystanych do osiągnięcia rozwiązania. Po wyciągnięciu z niego elementu zaznacza on wybraną komórkę,
    \item \texttt{show\_solution(results: SolverResults, step: bool) -> Optional[Generator]} - przeprowadza procedurę zaznaczania rozwiązania na planszy. Jeśli parametr \texttt{step} jest prawdą - zwraca generator opisany w poprzednim punkcie, w przeciwnym wypadku zaznacza wszystkie od razu,
    \item \texttt{remove\_markings() -> None} - usuwa zaznaczenia z komórek planszy,
    \item \texttt{as\_values() -> List[List[int]]} - zwraca macierz liczb całkowitych reprezentujących aktualne wartości komórek planszy.
\end{itemize}

\subsubsection{Klasa \texttt{App}}

To klasa dziedzicząca z głównej klasy biblioteki \texttt{tkinter}, otrzymująca z niej wszystkie właściwości
okna. Rozszerzono ją o atrybuty i metody wymagane w naszym zastosowaniu - takie jak flagi \texttt{is\_animating}
oraz \texttt{is\_solving}, które sygnalizują wykonywanie ciągłych operacji i pomagają w sterowaniu przepływem programu.

Zaimplementowane w klasie metody to:

\begin{itemize}
    \item \texttt{create\_main\_menu() -> None} - tworzy okno menu głównego wraz z przyciskami i polami tekstowymi,
    \item \texttt{file\_info() -> None} - wyświetla dialog informujący o strukturze otwieranego pliku z danymi do rozwiązania,
    \item \texttt{save\_to\_file() -> None} - przeprowadza procedurę zapisu do pliku stworzonej w programie planszy,
    \item \texttt{open\_board\_from\_file() -> None} - przeprowadza procedurę odczytu planszy z pliku,
    \item \texttt{handle\_solution\_button() -> None} - obsługuje kliknięcie przycisku rozwiązania - waliduje dane wejściowe i wywołuje rozwiązywanie problemu przez \textit{MiniZinc} w osobnym wątku,
    \item \texttt{handle\_rogo\_solve(arguments: SolverArguments) -> None} - definiuje procedurę wykonywaną przez osobny wątek, która dotyczy rozwiązania łamigłówki i wyświetlenia informacji o wynikach,
    \item \texttt{show\_summary() -> None} - tworzy panel podsumowania i wyświetla informacje o rozwiązaniu,
    \item \texttt{animate\_solution(solution: SolverResults, timeout: int) -> None} - rozpoczyna procedurę wyświetlania krok po kroku wyboru pól w otrzymanym rozwiązaniu łamigłówki,
    \item \texttt{\_\_handle\_step(gen: Generator, timeout: int) -> None} - wykonuje rekurencyjnie procedurę prezentowania kroków rozwiązania,
    \item \texttt{get\_args\_from\_app\_state() -> SolverArguments} - pobiera z pól w menu dane będące argumentami solvera i tworzy z nich obiekt klasy \texttt{SolverArguments},
    \item \texttt{create\_board(canvas: Optional[List[List[int]]]) -> None} - tworzy planszę do wypełniania o rozmiarach podanych w polach menu. Jeśli otrzyma parametr \texttt{canvas} będący liczbami istniejącej planszy wprowadza odpowiadające wartości w pola.
\end{itemize}

Odziedziczona z klasy \texttt{tkinter.Tk} metoda \texttt{mainloop()} uruchamia cały program.

\subsection{Funkcje oraz procedury}

\dots

\section{Użytkowanie i testowanie systemu}

\dots

\subsection{Interfejs aplikacji}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{2.png}
    \centering
    \caption{Ekran startowy aplikacji}
    \label{fig:ekran_startowy}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{1.png}
    \centering
    \caption{Okno podglądu rozwiązania}
    \label{fig:rozwiazanie}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{3.png}
    \centering
    \caption{Okno z informacją o oczekiwanej strukturze pliku}
    \label{fig:info}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{4.png}
    \centering
    \caption{Wyświetlenie informacji o błędnie wypełnionej planszy}
    \label{fig:blad}
\end{figure}

\subsection{Sterowanie aplikacją}

\dots

\subsection{Testy aplikacji}

\dots


\newpage

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}