\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english, polish]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{import}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage[justification=centering]{caption}
\usepackage{minted}

\usemintedstyle{emacs}


\graphicspath{{images/}}

\begin{document}

\begin{flushright}
    \today
\end{flushright}

\begin{flushleft}
    \begin{tabular}{ll}
        Bartosz Kosmala  & 140726 \\
        Hubert Knioła    & 139644 \\
        Mateusz Kuźniak  & 139092 \\
        Jordan Kondracki & 140721
    \end{tabular}
\end{flushleft}

\vspace{0.5cm}

\begin{center}
    \textbf{Sztuczna Inteligencja - laboratorium}\\[0.3cm]
    Sprawozdanie robocze, wariant 3\\[0.3cm]
    \textit{\textbf{Algorytm rozwiązujący Bag Puzzle z wykorzystaniem paradygmatu CSP/FD}}
\end{center}

\vspace{0.5cm}

\newenvironment{longlisting}{\captionsetup{type=listing}}{\hfill}

\section{Zmiany}

W tym rozdziale opiszemy zmiany i postępy prac poczynione przez ostatnie
dwa tygodnie.

\subsection{Algorytm rozwiązujący łamigłówkę}

Rozpoczęliśmy szkolenie udostępnione nam przez Prowadzącego 
na platformie \textit{Coursea} \cite{course}.

Z dotychczas zdobytych wiadomości udało nam się przygotować wstępny zarys
rozwiązania w języku \textit{MiniZinc}. Jest on widoczny na listingu \ref{lst:kod}.
W aktualnej formie wypełnia on ścieżkę o zadaną liczbę pól w prawo i w dół dla
pierwszej napotkanej liczby. Wynik jego działania można zauważyć na rysunku
\ref{fig:wynik}.

Największym problemem w realizacji przydzielonego nam zadania semestralnego
okazuje się zdefiniowanie ograniczeń w środowisku \textit{MiniZinc}.


\begin{longlisting}
    \begin{minted}[breaklines, linenos, frame=lines]{csharp}
int: x = 10;
set of int: RANGE = 1..x;
set of int: RANGE1 = 0..x;
set of int: RANGE2 = 2..x - 1;
array[RANGE, RANGE] of var RANGE1: plansza;
/* 
0 - ściana
1 - ścieżka
*/

constraint plansza[1,1] = 6;
constraint plansza[7,1] = 2;
constraint plansza[5,5] = 4;
constraint plansza[10,3] = 7;
constraint plansza[10,1] = 1;

int: n=0;
int: m=0;

/*ograniczenia dla pól z liczbą większą niż 1 określające widzenie z tego pola n pól gdzie n to liczba danego pola*/
constraint forall(i in RANGE, j in RANGE, n = plansza[i,j], m = plansza[i,j])(
  if plansza[i,j] > 1 then 
    forall(k in 1..n - 1 where m > 0)(
      plansza[i,j + k] = 1
    )
  endif);



/*ograniczenia związane z posiadaniem sąsiada*/

/*środek planszy*/
constraint forall(i in RANGE2, j in RANGE2) (
  if plansza[i, j] > 0 then
    count(k in plansza[i - 1, j - 1..j + 1])(k>0) + count(k in plansza[i, j - 1..j + 1])(k>0) + count(k in plansza[i + 1, j - 1..j + 1])(k>0) > 1
  endif
  );

/*górna krawędź planszy bez narożników*/
constraint forall(i = 1, j in RANGE2) (
  if plansza[i, j] > 0 then
    count(k in plansza[i, j - 1..j + 1])(k>0) + count(k in plansza[i + 1, j - 1..j + 1])(k>0) > 1
  endif
  );

/*dolna krawędź planszy bez narożników*/
constraint forall(i = 10, j in RANGE2) (
  if plansza[i, j] > 0 then
    count(k in plansza[i, j - 1..j + 1])(k>0) + count(k in plansza[i - 1, j - 1..j + 1])(k>0) > 1
  endif
  );

/*lewa krawędź planszy bez narożników*/
constraint forall(i in RANGE2, j = 1) (
  if plansza[i, j] > 0 then
    count(k in plansza[i - 1, j..j + 1])(k>0) + count(k in plansza[i, j..j + 1])(k>0) + count(k in plansza[i + 1, j..j + 1])(k>0) > 1
  endif
  );

/*prawa krawędź planszy bez narożników*/
constraint forall(i in RANGE2, j = 10) (
  if plansza[i, j] > 0 then
    count(k in plansza[i - 1, j - 1..j])(k>0) + count(k in plansza[i, j - 1..j])(k>0) + count(k in plansza[i + 1,j - 1..j])(k>0) > 1
  endif
  );

/*lewy-górny narożnik planszy*/
constraint forall(i = 1, j = 1) (
  if plansza[i, j] > 0 then
    count(k in plansza[i, j..j + 1])(k>0) + count(k in plansza[i + 1, j..j + 1])(k>0) > 1
  endif
  );

/*prawy-górny narożnik planszy*/
constraint forall(i = 1, j = 10) (
  if plansza[i, j] > 0 then
    count(k in plansza[i, j - 1..j])(k>0) + count(k in plansza[i + 1, j - 1..j])(k>0) > 1
  endif
  );

/*lewy-dolny narożnik planszy*/
constraint forall(i = 10, j = 1) (
  if plansza[i, j] > 0 then
    count(k in plansza[i, j..j + 1])(k>0) + count(k in plansza[i - 1, j..j + 1])(k>0) > 1
  endif
  );

/*prawy-dolny narożnik planszy*/
constraint forall(i = 10, j = 10) (
  if plansza[i, j] > 0 then
    count(k in plansza[i, j - 1..j])(k>0) + count(k in plansza[i - 1, j - 1..j])(k>0) > 1
  endif
  );

output [show([plansza[i,j]| j in RANGE]) ++ "\n"| i in RANGE];

solve satisfy;
    \end{minted}
    \caption{Algorytm rozwiązujący \textit{BagPuzzle}}
    \label{lst:kod}
\end{longlisting}

\begin{figure}[h]
    \includegraphics{wyniki2.png}
    \centering
    \caption{Wynik działania kodu z listingu \ref{lst:kod}}
    \label{fig:wynik}
\end{figure}

\newpage

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}